# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mQ6toZDmq5P6cbbeS6CqElKretuS9o5z
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

#reading the csv file
df=pd.read_csv('worlddata.csv')

#displaying the first few rows of the dataset
df.head()

#numple of rows and colums in the dataset
df.shape

#information of each row of the dataset
df.info()

df.describe()

#finding the categorical and numerical features
categorical=[]
numerical=[]

for col in df.columns:
  if df[col].dtype=='O':
    categorical.append(col)
  else:
    numerical.append(col)

print("The categorical features are: " ,categorical)
print("The numerical features are: " ,numerical)

"""#Exploratory Data Analysis

"""

df.hist(figsize=(30,30))

#Distribution of the CPI (Output Column)
sns.displot(df['cpi'], kde=True)

"""##  Missing Values"""

#no of missing values in each column
df.isnull().sum()

#percentage of missing values in each column
percent_missing = df.isnull().sum()*100/len(df)
print(percent_missing)

sns.heatmap(df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

""" Handling Missing Values in each numerical column by replacing the missing values with the mean value of the respective column"""

#replacing by mean
for columns in df.columns:
  if df[columns].isnull().sum()>0 and df[columns].dtype !='O':
    df[columns].fillna(df[columns].mean(),inplace=True)

df.isnull().sum()

sns.heatmap(df.isnull(),yticklabels=False,cbar=False,cmap='viridis')

"""## Converting Categorical to Numerical Features"""

#unique values in categorical features
for col in categorical:
  print("Unique values in", col, "are: ", df[col].unique())

#count of each unique value in column country
df['country'].value_counts()

#count of each unique value in column income_class
df['income_class'].value_counts()

#one hot encoding on categorical features to convert to numerical features
df=pd.get_dummies(df,columns=['country','income_class'])
df

"""## Outliers"""

df.boxplot(["electricity_access"])

df.boxplot(["gdp"])

df.boxplot(["gdp_capita"])

df.boxplot(["labor_rate"])

df.boxplot(["labor_force"])

df.boxplot(["land_area"])

df.boxplot(["life_expectancy"])

df.boxplot(["adult_literacy"])

df.boxplot(["water_access"])

df.boxplot(["air_pollution"])

df.boxplot(["population_density"])

"""Removing outliers"""

for columns in numerical:
  Q3=df[columns].quantile(0.75)
  Q1=df[columns].quantile(0.25)
  IQR=Q3-Q1
  Upper_bound=Q3+1.5*IQR
  lower_bound=Q1-1.5*IQR
  df.loc[df[columns]>=Upper_bound,columns]=Upper_bound
  df.loc[df[columns]<=lower_bound,columns]=lower_bound

#outliers
df.boxplot(["electricity_access"])

df.boxplot(["gdp"])

df.boxplot(["gdp_capita"])

#skewness
old_skew = df.skew()

print("Skewness of each column:")
print(old_skew)

df['cpi'].skew()

for col in df.columns:
  if df[col].dtype !='O':
    df[col]=np.log(df[col]+1)

df.skew()

"""# Model Development using Random Forest Regression"""

X=df.drop(columns='cpi',axis=0)
y=df.cpi

X

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

regressor = RandomForestRegressor(n_estimators=10, random_state=0, oob_score=True)
regressor.fit(X_train, y_train)

y_pred = regressor.predict(X_test)

# Create a DataFrame to display the actual values and predicted values
predictions_df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
print(predictions_df)

from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error: {mse}')
mae = mean_absolute_error(y_test, y_pred)
print(f'MAE:{mae}')

r2 = r2_score(y_test, y_pred)
print(f'R-squared: {r2}')

# import pickle
# filename = 'modelforcpi.sav'
# pickle.dump(regressor, open(filename, 'wb'))

list(X_test.columns)

with pd.option_context('display.max_rows', None, 'display.max_columns', None):  # more options can be specified also
    print(X.min())

